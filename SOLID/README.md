solid-принципы унифицируют правила по написанию кода

1. Single Responsibity(Принцип единственной отвественности)
   Класс решает одну задачу
   Если класс решает много задач то это антипаттерн god object - сложность в масштабировании и тестировании
   Декомпозиция, повышение читаемости кода, меньше связанности

2. Open-closed principle(Принцип открытости/закрытости)
   Существующие классы должны быть открыты для расширения, но закрыты для изменения
   Плюсы:

   1. Отстутствует необходимость в регрессионном тестировании
   2. Уменьшение количества ошибок

3. Liskov Substitution Principle(Принцип подстановки Барбары Лисков)
   Функции и сущности, которые используют родительский тип, должны так же работать и с дочерними компонентами, при этом ничего не должно ломаться. Наследуемый класс должен дополнять, а не замещать родительский класс. Переопределять код родительского класса в дочерних классах нельзя!

4. Interface segregation principle(Принцип разделения интерфейса)
   Программные сущности не должны зависеть от методов которые они не используют.
   Плюсы:

   1. Избавление сущностей от методов, которые они не используют.
   2. Предсказуемость кода.
   3. Меньшая связанность кода.

5. Dependency inversion principle(Принцип инверсии зависимостей)
   Модули высокого уровня не должны зависеть от модулей низкого уровня. Они должны зависеть от абстракций. Абстракции не должны зависеть от деталей, и детали не должны зависеть от абстракций.
   Между слоями должна быть абстрактная прослойка.
